{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "camera.svelte",
    "canvas.svelte"
  ],
  "sourcesContent": [
    "<script>\n  let video;\n  import Canvas from \"./canvas.svelte\";\n  import { onMount } from \"svelte\";\n  onMount(() => {\n    if (navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices\n        .getUserMedia({\n          video: {\n            facingMode: {\n              exact: \"environment\"\n            }\n          }\n        })\n        .then(function(stream) {\n          video.srcObject = stream;\n          const track = stream.getVideoTracks()[0];\n          //Create image capture object and get camera capabilities\n          const imageCapture = new ImageCapture(track);\n          const photoCapabilities = imageCapture\n            .getPhotoCapabilities()\n            .then(() => {\n              let vbox = video.getBoundingClientRect();\n              let c = new Canvas({\n                target: document.body,\n                props: {\n                  ch: vbox.height,\n                  cw: vbox.width\n                }\n              });\n              //todo: check if camera has a torch\n              setTimeout(() => {\n                let btn = document.querySelector(\"#flashlight\");\n                btn.addEventListener(\"click\", () => {\n                  //let there be light!\n                  track.applyConstraints({\n                    advanced: [{ torch: true }]\n                  });\n                });\n              }, 1000);\n            });\n        })\n        .catch(function(err0r) {\n          console.log(\"Something went wrong!\", err0r);\n        });\n    }\n  });\n</script>\n\n<style>\n  video {\n    position: relative;\n    width:100%;\n    z-index: 5;\n  }\n</style>\n\n<video bind:this={video} autoplay playsinline />\n",
    "<script>\n  let canvas, ctx, img;\n  let markstate = \"mark-off\";\n  let swap = false;\n  let GA = 0.1;\n  let filterstate = false;\n  let slowstate = \"slo-mo\";\n  let gridNum = 10;\n  let slow = 1;\n  let zoom = 1;\n  let sx = 0;\n  let sy = 0;\n  let maxX = 0;\n  let maxY = 0;\n  let img2 = new Image();\n  export let ch, cw;\n  import { onMount } from \"svelte\";\n  onMount(() => {\n     canvas.height = ch;\n     canvas.width = cw;\n  });\n  let handleFiles = e => {\n    let URL = window.webkitURL || window.URL;\n    ctx = canvas.getContext(\"2d\");\n    img = new Image();\n    img.onload = () => {\n      maxX = img.width;\n      maxY = img.height;\n      canvas.width = img.width;\n      canvas.height = img.height;\n      let conversion = img.width / canvas.width;\n      //\n      ctx.drawImage(\n        img,\n        0,\n        0,\n        img.width,\n        img.height,\n        0,\n        0,\n        canvas.width,\n        img.height / conversion\n      );\n      img2.src = canvas.toDataURL();\n    };\n    let url = URL.createObjectURL(e.target.files[0]);\n    img.src = url;\n\n    // make the grid\n\n    // canvas events\n    let last = { x: 0, y: 0 };\n    let start;\n    let moving;\n    canvas.addEventListener(\n      \"touchstart\",\n      function(e) {\n        var touches = e.touches[0];\n        if (markstate == \"mark-on\") {\n          // make mark function\n          storeMark(touches.clientX, touches.clientY);\n        } else {\n          start = {\n            x: touches.clientX * slow,\n            y: touches.clientY * slow\n          };\n        }\n      },\n      false\n    );\n    canvas.addEventListener(\"touchmove\", function(e) {\n      if (markstate != \"mark-on\") {\n        var touch = e.touches[0];\n        moving = {\n          x: touch.clientX * slow,\n          y: touch.clientY * slow\n        };\n        let delta = { x: start.x - moving.x, y: start.y - moving.y };\n        sx = last.x + delta.x;\n        sy = last.y + delta.y;\n      }\n    });\n    canvas.addEventListener(\"touchend\", function(e) {\n      if (markstate != \"mark-on\") {\n        last = {\n          x: last.x + (start.x - moving.x),\n          y: last.y + (start.y - moving.y)\n        };\n      }\n    });\n    // Prevent scrolling when touching the canvas\n    document.body.addEventListener(\n      \"touchstart\",\n      function(e) {\n        if (e.target == canvas) {\n          e.preventDefault();\n        }\n      },\n      { passive: false }\n    );\n    document.body.addEventListener(\n      \"touchend\",\n      function(e) {\n        if (e.target == canvas) {\n          e.preventDefault();\n        }\n      },\n      { passive: false }\n    );\n    document.body.addEventListener(\n      \"touchmove\",\n      function(e) {\n        if (e.target == canvas) {\n          e.preventDefault();\n        }\n      },\n      { passive: false }\n    );\n  };\n  let reset = () => {\n    canvas.width = img.width;\n    canvas.height = img.height;\n    let conversion = img.width / canvas.width;\n    ctx.drawImage(\n      img,\n      0,\n      0,\n      img.width,\n      img.height,\n      0,\n      0,\n      canvas.width,\n      img.height / conversion\n    );\n    img2.src = canvas.toDataURL();\n  };\n  let storeMark = (x, y) => {\n    if (swap) {\n      canvas.width = img.width;\n      canvas.height = img.height;\n      let conversion = img.width / canvas.width;\n      ctx.drawImage(\n        img,\n        0,\n        0,\n        img.width,\n        img.height,\n        0,\n        0,\n        canvas.width,\n        img.height / conversion\n      );\n      swap = false;\n    } else {\n      ctx.fillStyle = \"red\";\n      ctx.fillRect(x, y, 5, 5);\n      img2.src = canvas.toDataURL();\n    }\n  };\n  let slowFunc = () => {\n    if (slow == 1) {\n      slow = 0.1;\n      slowstate = \"super-slow-mo\";\n    } else if (slow == 0.1) {\n      slow = 0.01;\n      slowstate = \"fast-mo\";\n    } else {\n      slow = 1;\n      slowstate = \"slo-mo\";\n    }\n  };\n  let markFunc = () => {\n    if (markstate == \"mark-on\") {\n      markstate = \"mark-off\";\n    } else {\n      markstate = \"mark-on\";\n      swap = true;\n    }\n  };\n\n  let func = () => {\n    if (ctx == undefined) return;\n\n    canvas.width = cw;\n    canvas.height = ch;\n    ctx.globalAlpha = GA;\n    ctx.drawImage(\n      img2,\n      sx,\n      sy,\n      img.width * zoom,\n      img.height * zoom,\n      0,\n      0,\n      (img.width * canvas.height) / img.height,\n      canvas.height\n    );\n  };\n  $: if (GA) {\n    console.log(sx, sy, GA, zoom);\n    func();\n  }\n  let grid = () => {\n    if (ctx == undefined) return;\n    console.log(\"running grid\");\n    canvas.width = img.width;\n    canvas.height = img.height;\n    let conversion = img.width / canvas.width;\n    ctx.drawImage(\n      img,\n      0,\n      0,\n      img.width,\n      img.height,\n      0,\n      0,\n      canvas.width,\n      img.height / conversion\n    );\n    // makee the x grid\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = \"red\";\n    for (let i = 0; i < gridNum; i++) {\n      ctx.beginPath();\n      ctx.moveTo(0, (canvas.height / gridNum) * i);\n      ctx.lineTo(canvas.width, (canvas.height / gridNum) * i);\n      ctx.closePath();\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo((canvas.width / gridNum) * i, 0);\n      ctx.lineTo((canvas.width / gridNum) * i, canvas.height);\n      ctx.closePath();\n      ctx.stroke();\n    }\n    img2.src = canvas.toDataURL();\n  };\n  $: if (gridNum) {\n    console.log(gridNum);\n    grid();\n  }\n</script>\n\n<style>\n  canvas {\n    position: absolute;\n    top:0px;\n    left:0px;\n    z-index: 20;\n  }\n</style>\n\n<canvas bind:this={canvas} />\n<div id=\"holder\">\n  <div id=\"fileupload\">\n    <input type=\"file\" on:change={handleFiles} />\n  </div>\n  <div id=\"zoom\">\n    <label for=\"\">\n      zoom\n      <input type=\"text\" min=\"0\" max=\"1\" bind:value={zoom} />\n      <input type=\"range\" min=\"0\" max=\"1\" step=\".0001\" bind:value={zoom} />\n    </label>\n  </div>\n  <div id=\"grid\">\n    <label for=\"\">\n      grid\n      <input type=\"text\" min=\"5\" max=\"20\" bind:value={gridNum} />\n      <input type=\"range\" min=\"5\" max=\"20\" step=\"1\" bind:value={gridNum} />\n    </label>\n  </div>\n  <div id=\"GA\">\n    <label for=\"\">\n      Global Alpha\n      <input type=\"text\" min=\"0\" max=\"1\" bind:value={GA} />\n      <input type=\"range\" min=\"0\" max=\"1\" step=\".001\" bind:value={GA} />\n    </label>\n  </div>\n  <div id=\"slowmo\">\n    <button on:click={slowFunc}>{slowstate}</button>\n  </div>\n  <div id=\"mark\">\n    <button on:click={markFunc}>{markstate}</button>\n  </div>\n  <div id=\"flash\">\n    <button id=\"flashlight\">flashlight</button>\n    <button on:click={reset}>Reset</button>\n  </div>\n</div>\n"
  ],
  "names": [],
  "mappings": "AAkDE,KAAK,cAAC,CAAC,AACL,QAAQ,CAAE,QAAQ,CAClB,MAAM,IAAI,CACV,OAAO,CAAE,CAAC,AACZ,CAAC;AC6LD,MAAM,eAAC,CAAC,AACN,QAAQ,CAAE,QAAQ,CAClB,IAAI,GAAG,CACP,KAAK,GAAG,CACR,OAAO,CAAE,EAAE,AACb,CAAC"
}