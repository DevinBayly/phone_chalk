{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "camera.svelte",
    "canvas.svelte"
  ],
  "sourcesContent": [
    "<script>\n  let video;\n  import Canvas from \"./canvas.svelte\";\n  import { onMount } from \"svelte\";\n  onMount(() => {\n    if (navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices\n        .getUserMedia({\n          video: {\n            facingMode: {\n              exact: \"environment\"\n            }\n          }\n        })\n        .then(function(stream) {\n          video.srcObject = stream;\n          const track = stream.getVideoTracks()[0];\n          //Create image capture object and get camera capabilities\n          const imageCapture = new ImageCapture(track);\n          const photoCapabilities = imageCapture\n            .getPhotoCapabilities()\n            .then(() => {\n              let vbox = video.getBoundingClientRect();\n              let c = new Canvas({\n                target: document.body,\n                props: {\n                  ch: vbox.height,\n                  cw: vbox.width\n                }\n              });\n              //todo: check if camera has a torch\n              setTimeout(() => {\n                let btn = document.querySelector(\"#flashlight\");\n                btn.addEventListener(\"click\", () => {\n                  //let there be light!\n                  track.applyConstraints({\n                    advanced: [{ torch: true }]\n                  });\n                });\n              }, 1000);\n            });\n        })\n        .catch(function(err0r) {\n          console.log(\"Something went wrong!\", err0r);\n        });\n    }\n  });\n</script>\n\n<style>\n  video {\n    position: relative;\n    width:100%;\n    z-index: 5;\n  }\n</style>\n\n<video bind:this={video} autoplay playsinline />\n",
    "<script>\n  //TODO make the program work for images that are taller than they are wide also.\n  export let cw, ch;\n  let canvas;\n  let editor = (() => ({\n    on: false,\n    active() {\n      return this.on;\n    },\n    run(x, y) {\n      if (markstate == \"mark-on\") {\n        this.mark(x, y);\n      }\n    },\n    mark(x, y) {\n      let bbox = canvas.getBoundingClientRect();\n      octx.fillStyle = \"red\";\n      x = x * (img.width / canvas.width) * img.width/img.height* zoom + sx - bbox.left;\n      y = y * (img.height / canvas.height)  * zoom +\n        sy -\n        bbox.top;\n      octx.fillRect(x, y, 5, 5);\n      img2.src = offscreen.toDataURL();\n    }\n  }))();\n  let offscreen;\n  let octx;\n  let gridNum;\n  let GA = 1;\n  let ctx;\n  let slowstate = 0;\n  let slow = 1;\n  let markstate = \"mark-off\";\n  let img = new Image();\n  let img2 = new Image();\n  import { onMount } from \"svelte\";\n  let sx = 0,\n    sy = 0,\n    zoom = 1;\n  let markFunc = () => {\n    if (markstate == \"mark-on\") {\n      markstate = \"mark-off\";\n    } else {\n      markstate = \"mark-on\";\n    }\n  };\n  let reset = () => {\n    // redraw on offcanvas and then reload the img2 and re issue draw canvas\n    octx.drawImage(img, 0, 0);\n    img2.src = offscreen.toDataURL();\n  };\n  let drawCanvas = () => {\n    if (canvas == undefined) return;\n    let finalwidth, finalheight;\n    if (img.height > img.width) {\n      finalwidth = (canvas.width * img.width) / img.height;\n      finalheight = canvas.height;\n    } else {\n      finalwidth = canvas.width*canvas.height/image.height;\n      finalheight = canvas.height ;\n    }\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.globalAlpha = GA;\n    ctx.drawImage(\n      img2,\n      sx,\n      sy,\n      img.width * zoom,\n      img.height * zoom,\n      0,\n      0,\n      finalwidth,\n      finalheight\n    );\n  };\n  let handlefile = (e)=> {\n    let file = e.target.files[0]\n    offscreen = document.createElement(\"canvas\");\n    ctx = canvas.getContext(\"2d\");\n    octx = offscreen.getContext(\"2d\");\n    img.onload = () => {\n      offscreen.height = img.height;\n      offscreen.width = img.width;\n      //\n      octx.drawImage(img, 0, 0);\n      let data = octx.getImageData(0, 0, offscreen.width, offscreen.height);\n      img2.src = offscreen.toDataURL();\n      // document.body.append(offscreen)\n      // console.log(img2)\n      //ctx.drawImage(img2,0,0,offscreen.width,offscreen.height,0,0,canvas.width,canvas.height)\n      //ctx.putImageData(data,0,0)\n    };\n    img.src = URL.createObjectURL(file);\n    img2.onload = () => {\n      drawCanvas();\n    };\n  }\n  onMount(() => {\n    // load chad,\n    // then have second image that you store the canvas as\n    canvas.height = ch;\n    canvas.width = cw;\n\n    let last = { x: 0, y: 0 };\n    let start;\n    let moving;\n    canvas.addEventListener(\n      \"touchstart\",\n      function(e) {\n        var touches = e.touches[0];\n        start = {\n          x: touches.clientX * slow,\n          y: touches.clientY * slow\n        };\n        editor.run(start.x, start.y);\n      },\n      false\n    );\n    canvas.addEventListener(\"touchmove\", function(e) {\n      var touch = e.touches[0];\n      moving = {\n        x: touch.clientX * slow,\n        y: touch.clientY * slow\n      };\n      let delta = { x: start.x - moving.x, y: start.y - moving.y };\n      sx = last.x + delta.x;\n      sy = last.y + delta.y;\n    });\n    canvas.addEventListener(\"touchend\", function(e) {\n      last = {\n        x: last.x + (start.x - moving.x),\n        y: last.y + (start.y - moving.y)\n      };\n    });\n    // Prevent scrolling when touching the canvas\n    document.body.addEventListener(\n      \"touchstart\",\n      function(e) {\n        if (e.target == canvas) {\n          e.preventDefault();\n        }\n      },\n      { passive: false }\n    );\n    document.body.addEventListener(\n      \"touchend\",\n      function(e) {\n        if (e.target == canvas) {\n          e.preventDefault();\n        }\n      },\n      { passive: false }\n    );\n    document.body.addEventListener(\n      \"touchmove\",\n      function(e) {\n        if (e.target == canvas) {\n          e.preventDefault();\n        }\n      },\n      { passive: false }\n    );\n  });\n  $: if (GA) {\n    console.log(sx, sy, zoom, GA);\n    drawCanvas();\n  }\n</script>\n\n<style>\n  canvas {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    z-index: 20;\n  }\n  #holder {\n    position: relative;\n    z-index: 30;\n    background: white;\n  }\n</style>\n\n<canvas bind:this={canvas} />\n\n<div id=\"holder\">\n  <div id=\"fileupload\">\n    <input type=\"file\" on:change={handlefile} />\n  </div>\n  <div id=\"zoom\">\n    <label for=\"\">\n      zoom\n      <input type=\"text\" min=\"0\" max=\"1\" bind:value={zoom} />\n      <input type=\"range\" min=\"0\" max=\"1\" step=\".0001\" bind:value={zoom} />\n    </label>\n  </div>\n  <div id=\"GA\">\n    <label for=\"\">\n      Global Alpha\n      <input type=\"text\" min=\"0\" max=\"1\" bind:value={GA} />\n      <input type=\"range\" min=\"0\" max=\"1\" step=\".001\" bind:value={GA} />\n    </label>\n  </div>\n  <div id=\"mark\">\n    <button on:click={markFunc}>{markstate}</button>\n  </div>\n  <div id=\"flash\">\n    <button id=\"flashlight\">flashlight</button>\n    <button on:click={reset}>Reset</button>\n  </div>\n</div>\n"
  ],
  "names": [],
  "mappings": "AAkDE,KAAK,cAAC,CAAC,AACL,QAAQ,CAAE,QAAQ,CAClB,MAAM,IAAI,CACV,OAAO,CAAE,CAAC,AACZ,CAAC;ACoHD,MAAM,eAAC,CAAC,AACN,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,GAAG,CACR,IAAI,CAAE,GAAG,CACT,OAAO,CAAE,EAAE,AACb,CAAC,AACD,OAAO,eAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,EAAE,CACX,UAAU,CAAE,KAAK,AACnB,CAAC"
}